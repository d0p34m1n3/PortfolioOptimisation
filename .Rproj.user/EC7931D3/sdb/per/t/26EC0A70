{
    "contents" : "NoOfCandidatesToDownload <- 200\nNoOfPositionsToKeep <- 100\nTargetBeta <- 0.5\nTargetVolatility <- 0.15\nMaxPositionSize <- 0.05\nMaxLeverage <- 3\nPeriodsPerYear <- 52 / 4\nPredictedMarketReturn <- (1 + 0.10) ^ (1/PeriodsPerYear) - 1\nPredictedMarketDispersion <- 0.1 # 0.1 for 4 Weeks, 0.05 for 1 Week\nPredictedMarketVolatility <- 0.18 / sqrt(PeriodsPerYear)\n\nBeep <- function(n=3) {\n  for (i in seq(n)) {\n    system(\"rundll32 user32.dll, MessageBeep -1\")\n    Sys.sleep(.5)\n  }\n}\n\nrequire(VGAM)\nrequire(rsqlserver)\nrequire(DBI)\nrequire(caret)\nrequire(MASS)\nrequire(car)\nrequire(doParallel)\nrequire(scales)\nrequire(dplyr)\nrequire(tidyr)\nrequire(xts)\n\ncat(\"PORTFOLIO OPTIMISATION SETUP\\n\")\n\n# Load all Common Functions\n#source(sprintf(\"%s/CommonFunctions.R\", ScriptDir))\nLog <- function(message, ...) cat(format(Sys.time(), \"%H:%M:%S\"), \"-\", sprintf(message, ...), \"\\n\")\n\n# Connect to SQL Server\nMDC <- dbConnect(\"SqlServer\", url=ConnectionString, timeout=600)\nLog(\"Connected to SQL Server\")\n\n# Download Divination\nDivination <-\n  dbGetQuery(MDC, paste(sep=\"\\n\",\n                        sprintf(\"select EntityId, Name, ShortName, SourceView, \"),\n                        sprintf(\"PeriodType, GroupingLevel\"),\n                        sprintf(\"from DivinationsPlus where EntityId = %i\", DivinationEntityId)\n                        ))\nLog(\"Divination: %s (%s)\", Divination$Name, DivinationEntityId)\n\n# Download Portfolio Entity\nPortfolioEntity <-\n  dbGetQuery(MDC,\n             paste(sep=\"\\n\",\n                   sprintf(\"select EntityId, Symbol, Name\"),\n                   sprintf(\"from Entities\"),\n                   sprintf(\"where EntityId = %i\", PortfolioEntityId)\n                   ))\nLog(\"Portfolio: %s (%s)\", PortfolioEntity$Name, PortfolioEntityId)\n\n#Download Portfolio Positions\nPortfolioPositions <-\n  dbGetQuery(MDC,\n             paste(sep=\"\\n\",\n                   sprintf(\"select PP.EntityId, E.Symbol, convert(int, sign(sum(PP.Quantity))) as LongOrShort, \"),\n                   sprintf(\"convert(float, sum(PP.Quantity)) as CurrentQuantity, avg(PP.Price) as Price, sum(PP.Amount) as CurrentAmount,\"),\n                   sprintf(\"avg(coalesce(iif(PP.Quantity>0, R.%sLongPred, -R.%sShortPred), 0)) as AlphaPrediction, \",\n                           Divination$ShortName, Divination$ShortName),\n                   sprintf(\"avg(PCR.ChangeVolPrediction) as VolatilityPrediction, \",\n                           Divination$ShortName, Divination$ShortName),\n                   sprintf(\"avg(coalesce(PC.BetaPrediction, case when PP.Quantity > 0 then 1.25 else 0.75 end)) as BetaPrediction,\"),\n                   sprintf(\"coalesce(exp(PC.ActualNext1WLogChange)-1, -999) as ActualReturn1W,\"),\n                   sprintf(\"coalesce(exp(PC.ActualNext4WLogChange)-1, -999) as ActualReturn4W,\"),\n                   sprintf(\"2*dbo.CalcTransCost(TCPriceTrading, 20000/nullif(TCPriceTrading, 0), TCAvgVolumn13W_WMavg * TCSplitFactor, TCVolatility, null) as Penalty,\"),\n                   sprintf(\"TCPriceTrading, TCAvgVolumn13W_WMavg * TCSplitFactor as TCAvgVolume, TCVolatility\"),\n                   sprintf(\"from PortfolioPositionsByDatePlus PP\"),\n                   sprintf(\"join PriceChangesRankings PCR\"),\n                   sprintf(\"on PCR.EntityId = PP.EntityId\"),\n                   sprintf(\"and PCR.Date = PP.Date\"),\n                   sprintf(\"join Entities E\"),\n                   sprintf(\"on E.EntityId = PP.EntityId\"),\n                   sprintf(\"and E.EntityType <> 'X'\"),\n                   sprintf(\"left outer join %sRankings R\", Divination$SourceView),\n                   sprintf(\"on R.EntityId = PP.EntityId\"),\n                   sprintf(\"and R.Date = PP.Date\"),\n                   sprintf(\"and iif(PP.Quantity>0, R.%sLongPred, R.%sShortPred) is not null\", Divination$ShortName, Divination$ShortName),\n                   sprintf(\"and iif(PP.Quantity>0, R.%sLongStdDev, R.%sShrtStdDev) > 0\", Divination$ShortName, Divination$ShortName),\n                   sprintf(\"left outer join PriceChanges PC\"),\n                   sprintf(\"on PC.EntityId = PP.EntityId\"),\n                   sprintf(\"and PC.Date = PP.Date\"),\n                   sprintf(\"left outer loop join (\"),\n                   sprintf(\"  select EntityID as TCEntityId, Date as TCDate, [Close] as TCPriceTrading,\"),\n                   sprintf(\"  convert(real, AdjVolume13W_WMAvg) as TCAvgVolumn13W_WMavg, \"),\n                   sprintf(\"  convert(real, Volume) / nullif(AdjVolume, 0) as TCSplitFactor,\"),\n                   sprintf(\"  Prev52WAnnualStdevLogChange as TCVolatility\"),\n                   sprintf(\"  from PriceChanges\"),\n                   sprintf(\") as TC\"),\n                   sprintf(\"on TC.TCEntityId = PP.EntityId\"),\n                   sprintf(\"and TC.TCDate = (select max(Date) from PriceChanges where EntityId = PP.EntityId and Date <= PP.Date)\"),\n                   sprintf(\"where PP.PortfolioEntityId = %i\", PortfolioEntityId),\n                   sprintf(\"and PP.Date = '%s'\", Date),\n                   sprintf(\"group by PP.EntityId, E.Symbol, PC.ActualNext1WLogChange, PC.ActualNext4WLogChange, \"),\n                   sprintf(\"TCPriceTrading, TCAvgVolumn13W_WMavg, TCSplitFactor, TCVolatility\"),\n                   sprintf(\"having sum(PP.Quantity) <> 0\")\n             ))\nPortfolioPositions$ActualReturn1W[PortfolioPositions$ActualReturn1W == -999] <- NA_real_\nPortfolioPositions$ActualReturn4W[PortfolioPositions$ActualReturn4W == -999] <- NA_real_\nPortfolioPositions$ReturnPrediction <- rep(0, times=nrow(PortfolioPositions))\nPortfolioPositions$ReturnPrediction[PortfolioPositions$CurrentQuantity < 0] <-\n  (PortfolioPositions$AlphaPrediction[PortfolioPositions$CurrentQuantity < 0] - PortfolioPositions$Penalty[PortfolioPositions$CurrentQuantity < 0] / 0.1) *\n  PredictedMarketDispersion + PredictedMarketReturn\nPortfolioPositions$ReturnPrediction[PortfolioPositions$CurrentQuantity > 0] <-\n  (PortfolioPositions$AlphaPrediction[PortfolioPositions$CurrentQuantity > 0] + PortfolioPositions$Penalty[PortfolioPositions$CurrentQuantity > 0] / 0.1) *\n  PredictedMarketDispersion + PredictedMarketReturn\nLog(\"Portfolio Positions: %s\", paste(sort(PortfolioPositions$Symbol), collapse=\", \"))\n\n#Download Long Candidates\nLongCandidates <-\n  dbGetQuery(MDC,\n             paste(sep=\"\\n\",\n                   sprintf(\"select top %i R.EntityId, E.Symbol, 1 as LongOrShort, \", NoOfCandidatesToDownload / 2),\n                   sprintf(\"0 as CurrentQuantity, PC.[Close] as Price, 0 as CurrentAmount,\"),\n                   sprintf(\"coalesce(R.%sLongPred, 0) as AlphaPrediction, \", Divination$ShortName),\n                   sprintf(\"PCR.ChangeVolPrediction as VolatilityPrediction, \", Divination$ShortName),\n                   sprintf(\"coalesce(PC.BetaPrediction, 0.75) as BetaPrediction,\"),\n                   sprintf(\"coalesce(exp(PC.ActualNext1WLogChange)-1, -999) as ActualReturn1W,\"),\n                   sprintf(\"coalesce(exp(PC.ActualNext4WLogChange)-1, -999) as ActualReturn4W,\"),\n                   sprintf(\"2*dbo.CalcTransCost(TCPriceTrading, 20000/nullif(TCPriceTrading, 0), TCAvgVolumn13W_WMavg * TCSplitFactor, TCVolatility, null) as Penalty,\"),\n                   sprintf(\"TCPriceTrading, TCAvgVolumn13W_WMavg * TCSplitFactor as TCAvgVolume, TCVolatility\"),\n                   sprintf(\"from %sRankings R\", Divination$SourceView),\n                   sprintf(\"join PriceChangesRankings PCR\"),\n                   sprintf(\"on PCR.EntityId = R.EntityId\"),\n                   sprintf(\"and PCR.Date = R.Date\"),\n                   sprintf(\"join Entities E\"),\n                   sprintf(\"on E.EntityId = R.EntityId\"),\n                   sprintf(\"left outer join PriceChanges PC\"),\n                   sprintf(\"on PC.EntityId = R.EntityId\"),\n                   sprintf(\"and PC.Date = R.Date\"),\n                   sprintf(\"left outer loop join (\"),\n                   sprintf(\"  select EntityID as TCEntityId, Date as TCDate, [Close] as TCPriceTrading,\"),\n                   sprintf(\"  convert(real, AdjVolume13W_WMAvg) as TCAvgVolumn13W_WMavg, \"),\n                   sprintf(\"  convert(real, Volume) / nullif(AdjVolume, 0) as TCSplitFactor,\"),\n                   sprintf(\"  Prev52WAnnualStdevLogChange as TCVolatility\"),\n                   sprintf(\"  from PriceChanges\"),\n                   sprintf(\") as TC\"),\n                   sprintf(\"on TC.TCEntityId = R.EntityId\"),\n                   sprintf(\"and TC.TCDate = (select max(Date) from PriceChanges where EntityId = R.EntityId and Date <= R.Date)\"),\n                   sprintf(\"where R.PassesFilter = 1\"),\n                   sprintf(\"and R.Passes%sFilter = 1\", Divination$Name),\n                   sprintf(\"and R.Date = '%s'\", Date),\n                   sprintf(\"and R.%sLongPred is not null\", Divination$ShortName),\n                   sprintf(\"and R.%sLongStdDev > 0\", Divination$ShortName),\n                   if (nrow(PortfolioPositions) > 0)\n                     sprintf(\"and R.EntityId not in (%s)\", paste(PortfolioPositions$EntityId, collapse=\", \")),\n                   sprintf(\"order by R.%sLongRskRwd desc\", Divination$ShortName)\n             ))\nLongCandidates$ActualReturn1W[LongCandidates$ActualReturn1W == -999] <- NA_real_\nLongCandidates$ActualReturn4W[LongCandidates$ActualReturn4W == -999] <- NA_real_\nLongCandidates$ReturnPrediction <-\n  (LongCandidates$AlphaPrediction + LongCandidates$Penalty / 0.1) * PredictedMarketDispersion + PredictedMarketReturn # 0.1 is the 4 week dispersion\nLog(\"Long Candidates: %s\", paste(sort(LongCandidates$Symbol), collapse=\", \"))\n\n#Download Short Candidates\nShortCandidates <-\n  dbGetQuery(MDC,\n             paste(sep=\"\\n\",\n                   sprintf(\"select top %i R.EntityId, E.Symbol, -1 as LongOrShort, \", NoOfCandidatesToDownload / 2),\n                   sprintf(\"0 as CurrentQuantity, PC.[Close] as Price, 0 as CurrentAmount,\"),\n                   sprintf(\"-coalesce(R.%sShortPred, 0) as AlphaPrediction, \", Divination$ShortName),\n                   sprintf(\"PCR.ChangeVolPrediction as VolatilityPrediction, \", Divination$ShortName),\n                   sprintf(\"coalesce(PC.BetaPrediction, 0.75) as BetaPrediction,\"),\n                   sprintf(\"coalesce(exp(PC.ActualNext1WLogChange)-1, -999) as ActualReturn1W,\"),\n                   sprintf(\"coalesce(exp(PC.ActualNext4WLogChange)-1, -999) as ActualReturn4W,\"),\n                   sprintf(\"2*dbo.CalcTransCost(TCPriceTrading, 20000/nullif(TCPriceTrading, 0), TCAvgVolumn13W_WMavg * TCSplitFactor, TCVolatility, null) as Penalty,\"),\n                   sprintf(\"TCPriceTrading, TCAvgVolumn13W_WMavg * TCSplitFactor as TCAvgVolume, TCVolatility\"),\n                   sprintf(\"from %sRankings R\", Divination$SourceView),\n                   sprintf(\"join PriceChangesRankings PCR\"),\n                   sprintf(\"on PCR.EntityId = R.EntityId\"),\n                   sprintf(\"and PCR.Date = R.Date\"),\n                   sprintf(\"join Entities E\"),\n                   sprintf(\"on E.EntityId = R.EntityId\"),\n                   sprintf(\"left outer join PriceChanges PC\"),\n                   sprintf(\"on PC.EntityId = R.EntityId\"),\n                   sprintf(\"and PC.Date = R.Date\"),\n                   sprintf(\"left outer loop join (\"),\n                   sprintf(\"  select EntityID as TCEntityId, Date as TCDate, [Close] as TCPriceTrading,\"),\n                   sprintf(\"  convert(real, AdjVolume13W_WMAvg) as TCAvgVolumn13W_WMavg, \"),\n                   sprintf(\"  convert(real, Volume) / nullif(AdjVolume, 0) as TCSplitFactor,\"),\n                   sprintf(\"  Prev52WAnnualStdevLogChange as TCVolatility\"),\n                   sprintf(\"  from PriceChanges\"),\n                   sprintf(\") as TC\"),\n                   sprintf(\"on TC.TCEntityId = R.EntityId\"),\n                   sprintf(\"and TC.TCDate = (select max(Date) from PriceChanges where EntityId = R.EntityId and Date <= R.Date)\"),\n                   sprintf(\"where R.PassesFilter = 1\"),\n                   sprintf(\"and R.Passes%sFilter = 1\", Divination$Name),\n                   sprintf(\"and R.Date = '%s'\", Date),\n                   sprintf(\"and R.%sShortPred is not null\", Divination$ShortName),\n                   sprintf(\"and R.%sShrtStdDev > 0\", Divination$ShortName),\n                   if (nrow(PortfolioPositions) > 0)\n                     sprintf(\"and R.EntityId not in (%s)\", paste(PortfolioPositions$EntityId, collapse=\", \")),\n                   sprintf(\"order by R.%sShrtRskRwd desc\", Divination$ShortName)\n             ))\nShortCandidates$ActualReturn1W[ShortCandidates$ActualReturn1W == -999] <- NA_real_\nShortCandidates$ActualReturn4W[ShortCandidates$ActualReturn4W == -999] <- NA_real_\nShortCandidates$ReturnPrediction <-\n  (ShortCandidates$AlphaPrediction - ShortCandidates$Penalty / 0.1) * PredictedMarketDispersion + PredictedMarketReturn # 0.1 is the 4 week dispersion\nLog(\"Short Candidates: %s\", paste(sort(ShortCandidates$Symbol), collapse=\", \"))\n\n#Download SPY\nIndexCandidates <-\n  dbGetQuery(MDC,\n             paste(sep=\"\\n\",\n                   sprintf(\"select PCR.EntityId, E.Symbol, 0 as LongOrShort, \"),\n                   sprintf(\"0 as CurrentQuantity, PC.[Close] as Price, 0 as CurrentAmount,\"),\n                   sprintf(\"0 as AlphaPrediction, \"),\n                   sprintf(\"PCR.ChangeVolPrediction as VolatilityPrediction, \"),\n                   sprintf(\"coalesce(PC.BetaPrediction, 0.8) as BetaPrediction,\"),\n                   sprintf(\"coalesce(exp(PC.ActualNext1WLogChange)-1, -999) as ActualReturn1W,\"),\n                   sprintf(\"coalesce(exp(PC.ActualNext4WLogChange)-1, -999) as ActualReturn4W,\"),\n                   sprintf(\"2*dbo.CalcTransCost(TCPriceTrading, 20000/nullif(TCPriceTrading, 0), TCAvgVolumn13W_WMavg * TCSplitFactor, TCVolatility, null) as Penalty,\"),\n                   sprintf(\"TCPriceTrading, TCAvgVolumn13W_WMavg * TCSplitFactor as TCAvgVolume, TCVolatility\"),\n                   sprintf(\"from PriceChangesRankings PCR\"),\n                   sprintf(\"join Entities E\"),\n                   sprintf(\"on E.EntityId = PCR.EntityId\"),\n                   sprintf(\"left outer join PriceChanges PC\"),\n                   sprintf(\"on PC.EntityId = PCR.EntityId\"),\n                   sprintf(\"and PC.Date = PCR.Date\"),\n                   sprintf(\"left outer loop join (\"),\n                   sprintf(\"  select EntityID as TCEntityId, Date as TCDate, [Close] as TCPriceTrading,\"),\n                   sprintf(\"  convert(real, AdjVolume13W_WMAvg) as TCAvgVolumn13W_WMavg, \"),\n                   sprintf(\"  convert(real, Volume) / nullif(AdjVolume, 0) as TCSplitFactor,\"),\n                   sprintf(\"  Prev52WAnnualStdevLogChange as TCVolatility\"),\n                   sprintf(\"  from PriceChanges\"),\n                   sprintf(\") as TC\"),\n                   sprintf(\"on TC.TCEntityId = PCR.EntityId\"),\n                   sprintf(\"and TC.TCDate = (select max(Date) from PriceChanges where EntityId = PCR.EntityId and Date <= PCR.Date)\"),\n                   sprintf(\"where PCR.EntityId = dbo.GetTypedEntityId('SPY', 'E')\"),\n                   sprintf(\"and PCR.Date = '%s'\", Date),\n                   if (nrow(PortfolioPositions) > 0)\n                     sprintf(\"and PCR.EntityId not in (%s)\", paste(PortfolioPositions$EntityId, collapse=\", \"))\n             ))\nIndexCandidates$ActualReturn1W[IndexCandidates$ActualReturn1W == -999] <- NA_real_\nIndexCandidates$ActualReturn4W[IndexCandidates$ActualReturn4W == -999] <- NA_real_\nIndexCandidates$ReturnPrediction <- rep(PredictedMarketReturn, times=nrow(IndexCandidates))\nLog(\"Index Candidates: %s\", paste(sort(IndexCandidates$Symbol), collapse=\", \"))\n\n# Create Candidates Table\nCandidates <- rbind(PortfolioPositions, LongCandidates, ShortCandidates, IndexCandidates)\nCandidates <- Candidates %>% group_by(Symbol) %>% filter(n() == 1)\nCandidates <- Candidates[order(Candidates$Symbol), ]\n\n# Download Price Changes\nReturns <-\n  dbGetQuery(MDC,\n             paste(sep=\"\\n\",\n                   sprintf(\"select D.Date,\"),\n                   paste0(paste0(\"coalesce(avg(iif(P.EntityId = \", Candidates$EntityId, \", P.AdjLogChange, null)), -999) as \\\"\",\n                                Candidates$Symbol), \"\\\"\", collapse=\",\\n\"),\n                   sprintf(\"from DailyDates D\"),\n                   sprintf(\"left outer join Prices P\"),\n                   sprintf(\"on P.Date = D.Date\"),\n                   sprintf(\"where D.Date between DateAdd(year, -3, '%s') and '%s'\", Date, Date),\n                   sprintf(\"and P.EntityId in (%s)\", paste(Candidates$EntityId, collapse=\", \")),\n                   sprintf(\"group by D.Date\"),\n                   sprintf(\"order by D.Date desc\")\n             ),\n             timeout=600)\nfor (Symbol in names(Returns[-1]))\n  Returns[Returns[, Symbol] == -999, Symbol] <- NA_real_\nrownames(Returns) <- Returns$Date\nReturns$Date <- NULL\nReturns <- Returns[sapply(rownames(Returns), function(Date) sum(!is.na(Returns[Date, ]))) > length(colnames(Returns)) / 2, ]\nReturns <- Returns[, sapply(colnames(Returns), function(Symbol) sum(!is.na(Returns[, Symbol]))) > length(rownames(Returns)) / 2]\nLog(\"Returns downloaded for the past 3 years: %s\", prettyNum(nrow(Returns), digits=0, big.mark=\",\"))\n\n# Set Symbols and Dates\nSymbols <- colnames(Returns)\nDates <- rownames(Returns)\nLog(\"No of Symbols: %s\", prettyNum(length(Symbols), digits=0, big.mark=\",\"))\nLog(\"No of Dates: %s\", prettyNum(length(Dates), digits=0, big.mark=\",\"))\n\n# Reduce the Candidates List to those with Returns\nCandidates <- Candidates[Candidates$Symbol %in% Symbols, ]\n\n# Get the Portfolio Value\nPortfolioValue <- dbGetQuery(MDC, sprintf(\"select NetValue from PortfolioValues where PortfolioEntityId = %i and Date = '%s'\",\n                                          PortfolioEntityId, Date))[1, 1]\nLog(\"PortfolioValue: %s\", formatC(PortfolioValue, format=\"d\", big.mark=\",\"))\n\n# Close Connection\ndbDisconnect(MDC)\n\n# Fill in missing Values and convert to xts\nNoOfMissingValues <- sum(is.na(Returns))\nImputeModel <- preProcess(Returns, method=c(\"center\", \"scale\", \"knnImpute\"))\nReturns <- predict(ImputeModel, Returns)\nfor (Symbol in Symbols)\n  Returns[, Symbol][abs(Returns[, Symbol]) > 3] <- sign(Returns[, Symbol]) * 3\nReturns <- sapply(Symbols, function(Symbol) Returns[, Symbol] * ImputeModel$std[Symbol] + ImputeModel$mean[Symbol])\nReturns <- xts(Returns, order.by=as.Date(Dates))\nRemainingMissingValues <- sum(is.na(Returns))\nLog(\"Imputed %s missing values, %s remain\", prettyNum(NoOfMissingValues - RemainingMissingValues, digits=0, big.mark=\",\"),\n    prettyNum(RemainingMissingValues, digits=0, big.mark=\",\"))\n\n# Create PCAs\nPCAModel <- preProcess(Returns, method=c(\"center\", \"scale\", \"pca\"), pcaComp=5)\nPCAs <- predict(PCAModel, Returns) * PCAModel$std + PCAModel$mean\nLog(\"Created PCA's\")\n\nNoOfSymbols <- length(Symbols)\nCov <- cov(Returns)\nCov  <-  Cov *  (matrix(0.2, nrow=NoOfSymbols, ncol=NoOfSymbols) + 0.8 * diag(NoOfSymbols)) # Deflate Covariance Matrix\nPCACov <- cov(Returns %*% PCAModel$rotation)\n\nMinSteps <- pmax(1, signif(PortfolioValue * MaxLeverage / Candidates$Price / Candidates$Beta / NoOfPositionsToKeep / 5, digits=1))\nSteps <- rbind(diag(1, NoOfSymbols) * MinSteps, diag(-1, NoOfSymbols) * MinSteps)\n#Steps <- rbind(diag(1000, NoOfSymbols), diag(-1000, NoOfSymbols))\nClosePositionMultiplier <- matrix(1, nrow=NoOfSymbols, ncol=NoOfSymbols) - diag(NoOfSymbols)\n\nCalcTransCost <- function(PriceTrading, Shares, AvgDailyShares, AnnualVolatility) {\n  AnnualVolatility[is.na(AnnualVolatility)] <- 0.5\n  PriceTrading[is.na(PriceTrading)] <- 10\n  AvgDailyShares[is.na(AvgDailyShares)] <- 1000000 / PriceTrading[is.na(AvgDailyShares)]\n\n  InstantImpact1  = 35 * (100 * abs(Shares) / AvgDailyShares) ^ 0.65 + 0.3 * (10000 * AnnualVolatility / sqrt(252)) + 15\n  InstantImpact2  = 25 * (100 * abs(Shares) / AvgDailyShares) ^ 0.38 * (10000 * AnnualVolatility / sqrt(252)) ^ 0.28\n  InstantImpact  = (InstantImpact1 + InstantImpact2) / 2\n  MarketImpactCost  = InstantImpact * (0.95 * abs(Shares) / (abs(Shares) + AvgDailyShares / 2) + 0.05)\n  PriceMovementCost   = 0\n  FixedBrokerageCostBPS  = 0\n  FixedBrokerageCostCents  = 1.75\n\n  return ((MarketImpactCost + PriceMovementCost  + FixedBrokerageCostBPS) / 10000 + FixedBrokerageCostCents / PriceTrading / 100)\n}\n\nUtilityFunction <- function(Quantities) {\n  Leverage <- as.numeric(sum(abs(Quantities) * Candidates$Price) / PortfolioValue)\n  Beta <- as.numeric(sum(Quantities * Candidates$Price * Candidates$BetaPrediction) / PortfolioValue)\n  ExpectedReturn <- ((1 + 0.10 * pmax(Leverage, 1)) ^ (1 / PeriodsPerYear) - 1)\n  LongPositions <- sum(Quantities > 0)\n  ShortPositions <- sum(Quantities < 0)\n\n  SD <- as.numeric(sqrt(t(Quantities * Candidates$Price) %*% Cov %*% (Quantities * Candidates$Price) / PortfolioValue^2 * (252 / PeriodsPerYear)))\n  PCA_SD <- as.numeric(sqrt(t(Quantities * Candidates$Price) %*% PCAModel$rotation %*% PCACov %*% t(t(Quantities * Candidates$Price) %*% PCAModel$rotation) / PortfolioValue^2 * 252 / PeriodsPerYear))\n  UseSD <- pmax(PCA_SD, SD)\n\n  Return  <- as.numeric(sum(Quantities * Candidates$Price * Candidates$ReturnPrediction) / PortfolioValue)\n\n  LeveragePenalty <-\n    if (Leverage > MaxLeverage) -Inf else\n      (0.05 + -0.05 / (1 - (Leverage / MaxLeverage))) * ExpectedReturn\n\n  PositionSizePenalty <- if(any(abs(Quantities * Candidates$Price) > MaxPositionSize * pmax(Leverage, 1) * PortfolioValue)) -Inf else 0\n\n  TargetVolatilityPenalty <- if(UseSD == 0) -Inf else -log(UseSD * sqrt(PeriodsPerYear) / TargetVolatility)^2 * 20 * ExpectedReturn\n\n  TransactionCostPenalty <- -2 * sum(CalcTransCost(Candidates$TCPriceTrading, abs(Candidates$CurrentQuantity - Quantities), Candidates$TCAvgVolume, Candidates$TCVolatility) * abs(Candidates$CurrentQuantity - Quantities) * Candidates$Price) / PortfolioValue\n\n  UtilityScore <-\n    if(UseSD == 0) -Inf else\n      Return / UseSD * sqrt(PeriodsPerYear) +\n    (LeveragePenalty + PositionSizePenalty + TargetVolatilityPenalty + TransactionCostPenalty) / pmax(UseSD * sqrt(PeriodsPerYear), TargetVolatility)\n\n  Utility <- data.frame(NoOfLongPositions=LongPositions, NoOfShortPositions=ShortPositions, Leverage=Leverage, Beta=Beta,\n                        SD=SD, PCA_SD=PCA_SD, Return=Return, LeveragePenalty=LeveragePenalty,\n                        TargetVolatilityPenalty=TargetVolatilityPenalty, PositionSizePenalty=PositionSizePenalty,\n                        TransactionCostPenalty=TransactionCostPenalty, Score=UtilityScore)\n}\n\nQuantities <- Candidates$CurrentQuantity\nBestUtility <- UtilityFunction(Quantities)\nwhile(BestUtility$PositionSizePenalty == -Inf & any(Quantities != 0)) {\n  Quantities <- Quantities - sign(Quantities) * pmax(rep(0, times=length(Quantities)), abs(Quantities) - MinSteps)\n  BestUtility <- UtilityFunction(Quantities)\n}\n\n\nUtility <- BestUtility\nIteration <- 0\nIterations <- data.frame()\nMaxPositionsUtility <- BestUtility\nMaxPositionsQuantities <- numeric()\n\nrepeat {\n  Iterations <- rbind(Iterations, data.frame(Iteration=Iteration, Utility=BestUtility))\n  Iteration <- Iteration + 1\n  NewQuantities <- rep(1, times = 2 * NoOfSymbols) %*% t(Quantities) + Steps\n  for (i in 1:(2 * NoOfSymbols)) {\n    NewQuantities[i, NewQuantities[i, ] != 0 & abs(NewQuantities[i, ]) * Candidates$Price * Candidates$BetaPrediction <\n                    sum(abs(NewQuantities[i, ] * Candidates$Price)) / NoOfPositionsToKeep / 4 &\n                    abs(NewQuantities[i, ]) < abs(Quantities)] <- 0\n    NewQuantities[i, ][sign(NewQuantities[i, ]) * Candidates$LongOrShort == -1] <- 0\n  }\n  NewQuantities <-\n    foreach (Row = 1:nrow(NewQuantities), .combine=rbind, .inorder=T) %do% if (any(NewQuantities[Row, ] != Quantities)) NewQuantities[Row, ]\n\n  NewUtilities <- foreach (Row = 1:nrow(NewQuantities), .combine=rbind, .inorder=T) %dopar% UtilityFunction(NewQuantities[Row, ])\n  NewUtility <- NewUtilities[NewUtilities$Score == max(NewUtilities$Score), ]\n  if (NewUtility$Score <= BestUtility$Score) {\n    break\n  }\n  BestUtility <- NewUtility\n  Quantities <- NewQuantities[NewUtilities$Score==BestUtility$Score,]\n  if (!is.null(nrow(Quantities)))\n    if (nrow(Quantities) > 1) {\n      Quantities <- Quantities[1, ]\n    }\n\n  if (sum(Quantities != 0) >= NoOfPositionsToKeep) {\n    if (BestUtility$Score <= MaxPositionsUtility$Score) {\n      BestUtility <- MaxPositionsUtility\n      Quantities <- MaxPositionsQuantities\n      break\n    }\n    else {\n      MaxPositionsUtility <- BestUtility\n      MaxPositionsQuantities <- Quantities\n\n      for (j in 1:(NoOfPositionsToKeep / 10)) {\n        NewQuantities <- ((rep(1, times = NoOfSymbols) %*% t(Quantities)) * ClosePositionMultiplier)[Quantities != 0, ]\n        NewUtilities <- foreach (Row = 1:nrow(NewQuantities), .combine=rbind) %do% UtilityFunction(NewQuantities[Row, ])\n        NewUtility <- NewUtilities[NewUtilities$Score == max(NewUtilities$Score), ]\n        Quantities <- NewQuantities[NewUtilities$Score==NewUtility$Score,]\n        if (!is.null(nrow(Quantities)))\n          if (nrow(Quantities) > 1) {\n            Quantities <- Quantities[1, ]\n          }\n      }\n      BestUtility <- NewUtility\n    }\n  }\n\n  Log(\"%i : Long=%i, Shorts=%i, Leverage=%.1f, Beta=%.1f, Return=%.1f%%, SD=%.1f%%, PCA-SD=%.1f%%, LeveragePen=%.2f%%, TargetVolPen=%.2f%%, TransCostPen==%.2f%%, Score=%.3f\\n\",\n              Iteration, BestUtility$NoOfLongPositions, BestUtility$NoOfShortPositions, BestUtility$Leverage, BestUtility$Beta,\n              100*(((BestUtility$Return + 1) ^ 2 - pmax(BestUtility$SD, BestUtility$PCA_SD)^2)^(PeriodsPerYear / 2) - 1),\n              100*BestUtility$SD*sqrt(PeriodsPerYear), 100*BestUtility$PCA_SD*sqrt(PeriodsPerYear),\n              100*BestUtility$LeveragePenalty, 100*BestUtility$TargetVolatilityPenalty, 100*BestUtility$TransactionCostPenalty, BestUtility$Score)\n}\n\n# Connect to SQL Server\nMDC <- dbConnect(\"SqlServer\", url=ConnectionString)\nLog(\"Reconnected to SQL Server\")\n\ndbNonQuery(MDC, sprintf(\"delete from PortfolioPositions where PortfolioEntityId = %i\", NewPortfolioEntityId))\nNoOfPositions <- sum(Quantities != 0)\nScript <- paste(collapse=\"\\n\",\n                sprintf(\"insert into PortfolioPositions(PortfolioEntityId, EntityId, Category, StartDate, EndDate, Quantity) values (%i, %i, 'Dva', '%s', '%s', %i)\",\n                  rep(NewPortfolioEntityId, NoOfPositions),\n                  Candidates$EntityId[Quantities != 0],\n                  rep(Date, NoOfPositions),\n                  rep(Date, NoOfPositions),\n                  Quantities[Quantities != 0]))\ndbNonQuery(MDC, Script)\ndbDisconnect(MDC)",
    "created" : 1431606429953.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2637124176",
    "id" : "26EC0A70",
    "lastKnownWriteTime" : 1431650411,
    "path" : "D:/MindlessInvesting/R/Scripts/EquityModelPortfolioOptimisation.R",
    "project_path" : null,
    "properties" : {
        "tempName" : "Untitled1"
    },
    "source_on_save" : false,
    "type" : "r_source"
}