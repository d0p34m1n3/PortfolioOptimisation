{
    "contents" : "# Download Price Changes\nReturns <-\n  dbGetQuery(MDC,\n             paste(sep=\"\\n\",\n                   sprintf(\"select D.Date,\"),\n                   paste0(paste0(\"coalesce(avg(iif(P.EntityId = \", Candidates$EntityId, \", P.AdjLogChange, null)), -999) as \\\"\",\n                                 Candidates$Symbol), \"\\\"\", collapse=\",\\n\"),\n                   sprintf(\"from DailyDates D\"),\n                   sprintf(\"left outer join Prices P\"),\n                   sprintf(\"on P.Date = D.Date\"),\n                   sprintf(\"where D.Date between DateAdd(year, -3, '%s') and '%s'\", Date, Date),\n                   sprintf(\"and P.EntityId in (%s)\", paste(Candidates$EntityId, collapse=\", \")),\n                   sprintf(\"group by D.Date\"),\n                   sprintf(\"order by D.Date desc\")\n             ),\n             commandTimeout=600)\nfor (Symbol in names(Returns[-1]))\n  Returns[Returns[, Symbol] == -999, Symbol] <- NA_real_\nrownames(Returns) <- Returns$Date\nReturns$Date <- NULL\nReturns <- Returns[sapply(rownames(Returns), function(Date) sum(!is.na(Returns[Date, ]))) > length(colnames(Returns)) / 2, ]\nReturns <- Returns[, sapply(colnames(Returns), function(Symbol) sum(!is.na(Returns[, Symbol]))) > length(rownames(Returns)) / 2]\nLog(\"Returns downloaded for the past 3 years: %s\", prettyNum(nrow(Returns), digits=0, big.mark=\",\"))\n\n# Set Symbols and Dates\nSymbols <- colnames(Returns)\nDates <- rownames(Returns)\nLog(\"No of Symbols: %s\", prettyNum(length(Symbols), digits=0, big.mark=\",\"))\nLog(\"No of Dates: %s\", prettyNum(length(Dates), digits=0, big.mark=\",\"))\n\n# Reduce the Candidates List to those with Returns\nCandidates <- Candidates[Candidates$Symbol %in% Symbols, ]\n\n# Get the Portfolio Value\nPortfolioValue <- dbGetQuery(MDC, sprintf(\"select NetValue from PortfolioValues where PortfolioEntityId = %i and Date = '%s'\",\n                                          PortfolioEntityId, Date))[1, 1]\nLog(\"PortfolioValue: %s\", formatC(PortfolioValue, format=\"d\", big.mark=\",\"))\n\n# Fill in missing Values and convert to xts\nNoOfMissingValues <- sum(is.na(Returns))\nImputeModel <- preProcess(Returns, method=c(\"scale\", \"center\", \"knnImpute\"))\nInterimReturns <- predict(ImputeModel, Returns)\nNewReturns <- InterimReturns * ImputeModel$std + ImputeModel$mean\nImputeModel2 <- preProcess(Returns, method=c(\"scale\", \"center\"))\nInterimReturns2 <- predict(ImputeModel2, Returns)\nNewReturns2 <- sapply(Symbols, function(Symbol) InterimReturns2[, Symbol] * ImputeModel2$std[Symbol] + ImputeModel2$mean[Symbol])\n\n#Test\nprint(Returns[1:6, 1:6])\nprint(NewReturns[1:6, 1:6])\nprint(NewReturns2[1:6, 1:6])\nprint(InterimReturns[1:6, 1:6])\nprint(InterimReturns2[1:6, 1:6])\nprint(sapply(Symbols[1:6], function(Symbol) mean(Returns[, Symbol], na.rm=T)))\nprint(sapply(Symbols[1:6], function(Symbol) mean(NewReturns[!is.na(Returns[, Symbol]), Symbol], na.rm=T)))\nprint(ImputeModel$mean[1:6])\nprint(ImputeModel2$mean[1:6])\nprint(sapply(Symbols[1:6], function(Symbol) sd(Returns[, Symbol], na.rm=T)))\nprint(sapply(Symbols[1:6], function(Symbol) sd(NewReturns[!is.na(Returns[, Symbol]), Symbol], na.rm=T)))\nprint(ImputeModel$sd[1:6])\nprint(ImputeModel2$sd[1:6])\n\n",
    "created" : 1430503422948.000,
    "dirty" : true,
    "encoding" : "",
    "folds" : "",
    "hash" : "1533447190",
    "id" : "1B4098AF",
    "lastKnownWriteTime" : 1430423844,
    "path" : null,
    "project_path" : null,
    "properties" : {
        "tempName" : "Untitled1"
    },
    "source_on_save" : false,
    "type" : "r_source"
}